{"ast":null,"code":"import { SignIdentity, wrapDER, DER_COSE_OID, fromHex, toHex } from '@dfinity/agent';\nimport borc from 'borc';\nimport { randomBytes } from '@noble/hashes/utils';\nfunction _coseToDerEncodedBlob(cose) {\n  return wrapDER(cose, DER_COSE_OID).buffer;\n}\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData) {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\nexport class CosePublicKey {\n  constructor(_cose) {\n    this._cose = _cose;\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n  toDer() {\n    return this._encodedKey;\n  }\n  getCose() {\n    return this._cose;\n  }\n}\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge = '<ic0.app>') {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(credentialCreationOptions) {\n  const creds = await navigator.credentials.create(credentialCreationOptions !== null && credentialCreationOptions !== void 0 ? credentialCreationOptions : {\n    publicKey: {\n      authenticatorSelection: {\n        userVerification: 'preferred'\n      },\n      attestation: 'direct',\n      challenge: _createChallengeBuffer(),\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256\n      }],\n      rp: {\n        name: 'Internet Identity Service'\n      },\n      user: {\n        id: randomBytes(16),\n        name: 'Internet Identity',\n        displayName: 'Internet Identity'\n      }\n    }\n  });\n  // Validate that it's the correct type at runtime, since WebAuthn does not HAVE to\n  // reply with a PublicKeyCredential.\n  if (creds.response === undefined || !(creds.rawId instanceof ArrayBuffer)) {\n    return null;\n  } else {\n    return creds;\n  }\n}\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nvar PubKeyCoseAlgo;\n(function (PubKeyCoseAlgo) {\n  PubKeyCoseAlgo[PubKeyCoseAlgo[\"ECDSA_WITH_SHA256\"] = -7] = \"ECDSA_WITH_SHA256\";\n})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  constructor(rawId, cose, authenticatorAttachment) {\n    super();\n    this.rawId = rawId;\n    this.authenticatorAttachment = authenticatorAttachment;\n    this._publicKey = new CosePublicKey(cose);\n  }\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  static fromJSON(json) {\n    const {\n      publicKey,\n      rawId\n    } = JSON.parse(json);\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n    return new this(fromHex(rawId), fromHex(publicKey), undefined);\n  }\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  static async create(credentialCreationOptions) {\n    var _a;\n    const creds = await _createCredential(credentialCreationOptions);\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n    const response = creds.response;\n    if (!(response.attestationObject instanceof ArrayBuffer)) {\n      throw new Error('Was expecting an attestation response.');\n    }\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n    return new this(creds.rawId, _authDataToCose(attObject.authData), (_a = creds.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined);\n  }\n  getPublicKey() {\n    return this._publicKey;\n  }\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  getAuthenticatorAttachment() {\n    return this.authenticatorAttachment;\n  }\n  async sign(blob) {\n    const result = await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [{\n          type: 'public-key',\n          id: this.rawId\n        }],\n        challenge: blob,\n        userVerification: 'preferred'\n      }\n    });\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n    const response = result.response;\n    if (response.signature instanceof ArrayBuffer && response.authenticatorData instanceof ArrayBuffer) {\n      const cbor = borc.encode(new borc.Tagged(55799, {\n        authenticator_data: new Uint8Array(response.authenticatorData),\n        client_data_json: new TextDecoder().decode(response.clientDataJSON),\n        signature: new Uint8Array(response.signature)\n      }));\n      if (!cbor) {\n        throw new Error('failed to encode cbor');\n      }\n      return cbor.buffer;\n    } else {\n      throw new Error('Invalid response from WebAuthn.');\n    }\n  }\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  toJSON() {\n    return {\n      publicKey: toHex(this._publicKey.getCose()),\n      rawId: toHex(this.rawId)\n    };\n  }\n}","map":{"version":3,"names":["SignIdentity","wrapDER","DER_COSE_OID","fromHex","toHex","borc","randomBytes","_coseToDerEncodedBlob","cose","buffer","_authDataToCose","authData","dataView","DataView","ArrayBuffer","idLenBytes","slice","Uint8Array","forEach","v","i","setUint8","credentialIdLength","getUint16","CosePublicKey","constructor","_cose","_encodedKey","toDer","getCose","_createChallengeBuffer","challenge","from","c","charCodeAt","_createCredential","credentialCreationOptions","creds","navigator","credentials","create","publicKey","authenticatorSelection","userVerification","attestation","pubKeyCredParams","type","alg","PubKeyCoseAlgo","ECDSA_WITH_SHA256","rp","name","user","id","displayName","response","undefined","rawId","WebAuthnIdentity","authenticatorAttachment","_publicKey","fromJSON","json","JSON","parse","Error","attestationObject","attObject","decodeFirst","_a","getPublicKey","getAuthenticatorAttachment","sign","blob","result","get","allowCredentials","signature","authenticatorData","cbor","encode","Tagged","authenticator_data","client_data_json","TextDecoder","decode","clientDataJSON","toJSON"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\identity\\src\\identity\\webauthn.ts"],"sourcesContent":["import {\n  DerEncodedPublicKey,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  fromHex,\n  toHex,\n} from '@dfinity/agent';\nimport borc from 'borc';\nimport { randomBytes } from '@noble/hashes/utils';\n\nfunction _coseToDerEncodedBlob(cose: ArrayBuffer): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID).buffer as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: ArrayBuffer): ArrayBuffer {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: ArrayBuffer) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): ArrayBuffer {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment;\n\n  // Validate that it's the correct type at runtime, since WebAuthn does not HAVE to\n  // reply with a PublicKeyCredential.\n  if (creds.response === undefined || !(creds.rawId instanceof ArrayBuffer)) {\n    return null;\n  } else {\n    return creds;\n  }\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(fromHex(rawId), fromHex(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (!(response.attestationObject instanceof ArrayBuffer)) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n\n    return new this(\n      creds.rawId,\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: ArrayBuffer,\n    cose: ArrayBuffer,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: ArrayBuffer): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n    if (\n      response.signature instanceof ArrayBuffer &&\n      response.authenticatorData instanceof ArrayBuffer\n    ) {\n      const cbor = borc.encode(\n        new borc.Tagged(55799, {\n          authenticator_data: new Uint8Array(response.authenticatorData),\n          client_data_json: new TextDecoder().decode(response.clientDataJSON),\n          signature: new Uint8Array(response.signature),\n        }),\n      );\n      if (!cbor) {\n        throw new Error('failed to encode cbor');\n      }\n      return cbor.buffer as Signature;\n    } else {\n      throw new Error('Invalid response from WebAuthn.');\n    }\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: toHex(this._publicKey.getCose()),\n      rawId: toHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}