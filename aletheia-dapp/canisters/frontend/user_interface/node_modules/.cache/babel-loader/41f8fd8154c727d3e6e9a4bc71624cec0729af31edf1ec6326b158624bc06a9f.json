{"ast":null,"code":"/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers) {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes) {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString) {\n  var _a;\n  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {\n    this._buffer = buffer || new ArrayBuffer(0);\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n  get buffer() {\n    // Return a copy of the buffer.\n    return this._view.slice();\n  }\n  get byteLength() {\n    return this._view.byteLength;\n  }\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  read(num) {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n  readUint8() {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  write(buf) {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n    }\n    this._view.set(b, offset);\n  }\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  get end() {\n    return this._view.byteLength === 0;\n  }\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  alloc(amount) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}","map":{"version":3,"names":["concat","buffers","result","Uint8Array","reduce","acc","curr","byteLength","index","b","set","toHexString","bytes","str","byte","toString","padStart","fromHexString","hexString","_a","match","map","parseInt","PipeArrayBuffer","constructor","buffer","length","_buffer","ArrayBuffer","_view","slice","read","num","subarray","readUint8","write","buf","offset","byteOffset","alloc","end","amount","v"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\candid\\src\\utils\\buffer.ts"],"sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers: ArrayBuffer[]): ArrayBuffer {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes: ArrayBuffer): string {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString: string): ArrayBuffer {\n  return new Uint8Array((hexString.match(/.{1,2}/g) ?? []).map(byte => parseInt(byte, 16)));\n}\n\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * The reading view. It's a sliding window as we read and write, pointing to the buffer.\n   * @private\n   */\n  private _view: Uint8Array;\n\n  /**\n   * The actual buffer containing the bytes.\n   * @private\n   */\n  private _buffer: ArrayBuffer;\n\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer?: ArrayBuffer, length = buffer?.byteLength || 0) {\n    this._buffer = buffer || new ArrayBuffer(0);\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n\n  get buffer(): ArrayBuffer {\n    // Return a copy of the buffer.\n    return this._view.slice();\n  }\n\n  get byteLength(): number {\n    return this._view.byteLength;\n  }\n\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  public read(num: number): ArrayBuffer {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n\n  public readUint8(): number | undefined {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  public write(buf: ArrayBuffer): void {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(\n        this._buffer,\n        this._view.byteOffset,\n        this._view.byteLength + b.byteLength,\n      );\n    }\n\n    this._view.set(b, offset);\n  }\n\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  public get end(): boolean {\n    return this._view.byteLength === 0;\n  }\n\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  public alloc(amount: number) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}