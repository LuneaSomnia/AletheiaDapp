{"ast":null,"code":"/** @module AuthClient */\nimport { AnonymousIdentity } from '@dfinity/agent';\nimport { Delegation, DelegationChain, isDelegationValid, DelegationIdentity, Ed25519KeyIdentity, ECDSAKeyIdentity } from '@dfinity/identity';\nimport { IdleManager } from './idleManager';\nimport { IdbStorage, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY, KEY_VECTOR, LocalStorage } from './storage';\nexport { IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal } from './db';\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\nconst INTERRUPT_CHECK_INTERVAL = 500;\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\nexport * from './idleManager';\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  constructor(_identity, _key, _chain, _storage, idleManager, _createOptions,\n  // A handle on the IdP window.\n  _idpWindow,\n  // The event handler for processing events from the IdP.\n  _eventHandler) {\n    var _a;\n    this._identity = _identity;\n    this._key = _key;\n    this._chain = _chain;\n    this._storage = _storage;\n    this.idleManager = idleManager;\n    this._createOptions = _createOptions;\n    this._idpWindow = _idpWindow;\n    this._eventHandler = _eventHandler;\n    const logout = this.logout.bind(this);\n    const idleOptions = _createOptions === null || _createOptions === void 0 ? void 0 : _createOptions.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {\n      (_a = this.idleManager) === null || _a === void 0 ? void 0 : _a.registerCallback(() => {\n        logout();\n        location.reload();\n      });\n    }\n  }\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs {@link AuthClient}\n   * @param {AuthClientCreateOptions} options\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  static async create(options = {}) {\n    var _a, _b, _c;\n    const storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new IdbStorage();\n    const keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;\n    let key = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch (e) {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n    let identity = new AnonymousIdentity();\n    let chain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error('Delegation chain is incorrectly stored. A delegation chain should be stored as a string.');\n        }\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            identity = DelegationIdentity.fromDelegation(key, chain);\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager = undefined;\n    if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, key.getKeyPair());\n      }\n    }\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n  async _handleSuccess(message, onSuccess) {\n    var _a, _b, _c;\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),\n        signature: signedDelegation.signature.buffer\n      };\n    });\n    const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n    this._chain = delegationChain;\n    this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n    if (!this.idleManager) {\n      const idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;\n      this.idleManager = IdleManager.create(idleOptions);\n      if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {\n        (_c = this.idleManager) === null || _c === void 0 ? void 0 : _c.registerCallback(() => {\n          this.logout();\n          location.reload();\n        });\n      }\n    }\n    this._removeEventListener();\n    delete this._idpWindow;\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n  }\n  getIdentity() {\n    return this._identity;\n  }\n  async isAuthenticated() {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  async login(options) {\n    var _a, _b, _c, _d;\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */BigInt(8) * /* nanoseconds */BigInt(3600000000000);\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a === void 0 ? void 0 : _a.toString()) || IDENTITY_PROVIDER_DEFAULT);\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();\n    this._removeEventListener();\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({\n      maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive\n    }, options));\n    window.addEventListener('message', this._eventHandler);\n    // Open a new window with the IDP provider.\n    this._idpWindow = (_d = window.open(identityProviderUrl.toString(), 'idpWindow', options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : undefined;\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = () => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n  _getEventHandler(identityProviderUrl, options) {\n    return async event => {\n      var _a, _b, _c;\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(`WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`);\n        return;\n      }\n      const message = event.data;\n      switch (message.kind) {\n        case 'authorize-ready':\n          {\n            // IDP is ready. Send a message to request authorization.\n            const request = {\n              kind: 'authorize-client',\n              sessionPublicKey: new Uint8Array((_a = this._key) === null || _a === void 0 ? void 0 : _a.getPublicKey().toDer()),\n              maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive,\n              derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString()\n            };\n            (_c = this._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);\n            break;\n          }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);\n          } catch (err) {\n            this._handleFailure(err.message, options === null || options === void 0 ? void 0 : options.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n  _handleFailure(errorMessage, onError) {\n    var _a;\n    (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n    onError === null || onError === void 0 ? void 0 : onError(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n  _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n  async logout(options = {}) {\n    await _deleteStorage(this._storage);\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (e) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\nasync function _deleteStorage(storage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}","map":{"version":3,"names":["AnonymousIdentity","Delegation","DelegationChain","isDelegationValid","DelegationIdentity","Ed25519KeyIdentity","ECDSAKeyIdentity","IdleManager","IdbStorage","isBrowser","KEY_STORAGE_DELEGATION","KEY_STORAGE_KEY","KEY_VECTOR","LocalStorage","IdbKeyVal","IDENTITY_PROVIDER_DEFAULT","IDENTITY_PROVIDER_ENDPOINT","ECDSA_KEY_LABEL","ED25519_KEY_LABEL","INTERRUPT_CHECK_INTERVAL","ERROR_USER_INTERRUPT","AuthClient","constructor","_identity","_key","_chain","_storage","idleManager","_createOptions","_idpWindow","_eventHandler","logout","bind","idleOptions","onIdle","disableDefaultIdleCallback","_a","registerCallback","location","reload","create","options","storage","keyType","_b","key","identity","maybeIdentityStorage","get","fallbackLocalStorage","localChain","localKey","console","log","set","remove","error","fromJSON","fromKeyPair","e","chain","chainStorage","Error","_deleteStorage","fromDelegation","undefined","_c","disableIdle","generate","JSON","stringify","toJSON","warn","getKeyPair","_handleSuccess","message","onSuccess","delegations","map","signedDelegation","delegation","pubkey","expiration","targets","signature","buffer","delegationChain","fromDelegations","userPublicKey","close","_removeEventListener","getIdentity","isAuthenticated","getPrincipal","isAnonymous","login","defaultTimeToLive","BigInt","identityProviderUrl","URL","identityProvider","toString","hash","_getEventHandler","Object","assign","maxTimeToLive","window","addEventListener","_d","open","windowOpenerFeatures","checkInterruption","closed","_handleFailure","onError","setTimeout","event","origin","data","kind","request","sessionPublicKey","Uint8Array","getPublicKey","toDer","derivationOrigin","postMessage","err","text","errorMessage","removeEventListener","returnTo","history","pushState","href"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\auth-client\\src\\index.ts"],"sourcesContent":["/** @module AuthClient */\nimport {\n  AnonymousIdentity,\n  DerEncodedPublicKey,\n  Identity,\n  Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, IdleManagerOptions } from './idleManager';\nimport {\n  AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage';\n\nexport { IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal, DBCreateOptions } from './db';\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An identity to use as the base\n   */\n  identity?: SignIdentity | ECDSAKeyIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n   */\n  storage?: AuthClientStorage;\n  /**\n   * type to use for the base key\n   * @default 'ECDSA'\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use 'Ed25519' as the key type, as it can serialize to a string\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 30 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager';\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.ic0.app\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: (() => void) | (() => Promise<void>);\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: ((error?: string) => void) | ((error?: string) => Promise<void>);\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  derivationOrigin?: string;\n}\n\ninterface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs {@link AuthClient}\n   * @param {AuthClientCreateOptions} options\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(\n    options: {\n      /**\n       * An {@link Identity} to use as the base.\n       *  By default, a new {@link AnonymousIdentity}\n       */\n      identity?: SignIdentity;\n      /**\n       * {@link AuthClientStorage}\n       * @description Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n       */\n      storage?: AuthClientStorage;\n      /**\n       * type to use for the base key\n       * @default 'ECDSA'\n       * If you are using a custom storage provider that does not support CryptoKey storage,\n       * you should use 'Ed25519' as the key type, as it can serialize to a string\n       */\n      keyType?: BaseKeyType;\n      /**\n       * Options to handle idle timeouts\n       * @default after 10 minutes, invalidates the identity\n       */\n      idleOptions?: IdleOptions;\n    } = {},\n  ): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | ECDSAKeyIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch (e) {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity = new AnonymousIdentity();\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            identity = DelegationIdentity.fromDelegation(key, chain);\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined = undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity,\n    private _key: SignIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    const logout = this.logout.bind(this);\n    const idleOptions = _createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: () => void,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature.buffer as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey.buffer as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n    this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n\n    this._idpWindow?.close();\n    if (!this.idleManager) {\n      const idleOptions = this._createOptions?.idleOptions;\n      this.idleManager = IdleManager.create(idleOptions);\n\n      if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n        this.idleManager?.registerCallback(() => {\n          this.logout();\n          location.reload();\n        });\n      }\n    }\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.();\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: {\n    /**\n     * Identity provider\n     * @default \"https://identity.ic0.app\"\n     */\n    identityProvider?: string | URL;\n    /**\n     * Expiration of the authentication in nanoseconds\n     * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n     */\n    maxTimeToLive?: bigint;\n    /**\n     * Auth Window feature config string\n     * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n     */\n    /**\n     * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n     * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n     */\n    derivationOrigin?: string | URL;\n    windowOpenerFeatures?: string;\n    /**\n     * Callback once login has completed\n     */\n    onSuccess?: (() => void) | (() => Promise<void>);\n    /**\n     * Callback in case authentication fails\n     */\n    onError?: ((error?: string) => void) | ((error?: string) => Promise<void>);\n  }): Promise<void> {\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3_600_000_000_000);\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      options?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive: options?.maxTimeToLive ?? defaultTimeToLive,\n      ...options,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(identityProviderUrl.toString(), 'idpWindow', options?.windowOpenerFeatures) ??\n      undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(\n          `WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`,\n        );\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer() as ArrayBuffer),\n            maxTimeToLive: options?.maxTimeToLive,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (e) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}