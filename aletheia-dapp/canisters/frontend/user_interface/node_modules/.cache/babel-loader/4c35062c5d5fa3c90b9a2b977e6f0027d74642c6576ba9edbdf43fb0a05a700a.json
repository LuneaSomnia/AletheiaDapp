{"ast":null,"code":"import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as _strategy from './strategy';\nexport { _strategy as strategy };\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n */\nexport async function pollForResponse(agent, canisterId, requestId, strategy,\n// eslint-disable-next-line\nrequest, blsVerify) {\n  var _a;\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request !== null && request !== void 0 ? request : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, {\n    paths: [path]\n  }));\n  const state = await agent.readState(canisterId, {\n    paths: [path]\n  }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify\n  });\n  const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n  switch (status) {\n    case RequestStatusResponseStatus.Replied:\n      {\n        return cert.lookup([...path, 'reply']);\n      }\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n    case RequestStatusResponseStatus.Rejected:\n      {\n        const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];\n        const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));\n        throw new Error(`Call was rejected:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Reject code: ${rejectCode}\\n` + `  Reject text: ${rejectMessage}\\n`);\n      }\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(`Call was marked as done but we never saw the reply:\\n` + `  Request ID: ${toHex(requestId)}\\n`);\n  }\n  throw new Error('unreachable');\n}","map":{"version":3,"names":["RequestStatusResponseStatus","Certificate","toHex","_strategy","strategy","defaultStrategy","pollForResponse","agent","canisterId","requestId","request","blsVerify","path","TextEncoder","encode","currentRequest","_a","createReadStateRequest","call","paths","state","readState","undefined","rootKey","Error","cert","create","certificate","maybeBuf","lookup","status","Unknown","TextDecoder","decode","Replied","Received","Processing","Rejected","rejectCode","Uint8Array","rejectMessage","Done"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\polling\\index.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy,\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<ArrayBuffer> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n  const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return cert.lookup([...path, 'reply'])!;\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code'])!)[0];\n      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message'])!);\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}