{"ast":null,"code":"import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode } from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nimport managementCanisterIdl from './canisters/management_idl';\nexport class ActorCallError extends AgentError {\n  constructor(canisterId, methodName, type, props) {\n    super([`Call failed:`, `  Canister: ${canisterId.toText()}`, `  Method: ${methodName} (${type})`, ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`)].join('\\n'));\n    this.canisterId = canisterId;\n    this.methodName = methodName;\n    this.type = type;\n    this.props = props;\n  }\n}\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, result) {\n    var _a;\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message\n    });\n    this.result = result;\n  }\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, requestId, response) {\n    super(canisterId, methodName, 'update', Object.assign({\n      'Request ID': toHex(requestId)\n    }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {\n      'Error code': response.body.error_code\n    } : {}), {\n      'Reject code': String(response.body.reject_code),\n      'Reject message': response.body.reject_message\n    }) : {\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText\n    }));\n    this.requestId = requestId;\n    this.response = response;\n  }\n}\n/**\n * The mode used when installing a canister.\n */\nexport var CanisterInstallMode;\n(function (CanisterInstallMode) {\n  CanisterInstallMode[\"Install\"] = \"install\";\n  CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n  CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n  static async install(fields, config) {\n    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n    await getManagementCanister(config).install_code({\n      mode: {\n        [mode]: null\n      },\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId\n    });\n  }\n  static async createCanister(config) {\n    const {\n      canister_id: canisterId\n    } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: []\n    });\n    return canisterId;\n  }\n  static async createAndInstallCanister(interfaceFactory, fields, config) {\n    const canisterId = await this.createCanister(config);\n    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n  }\n  static createActorClass(interfaceFactory, options) {\n    const service = interfaceFactory({\n      IDL\n    });\n    class CanisterActor extends Actor {\n      constructor(config) {\n        if (!config.canisterId) throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {\n            canisterId\n          }),\n          service\n        });\n        for (const [methodName, func] of service._fields) {\n          if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n    return CanisterActor;\n  }\n  static createActor(interfaceFactory, configuration) {\n    if (!configuration.canisterId) {\n      throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n    }\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n  static createActorWithHttpDetails(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory, {\n      httpDetails: true\n    }))(configuration);\n  }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy\n};\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n  let caller;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg\n      });\n      switch (result.status) {\n        case \"rejected\" /* QueryResponseStatus.Rejected */:\n          throw new QueryCallRejectedError(cid, methodName, result);\n        case \"replied\" /* QueryResponseStatus.Replied */:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {\n            httpDetails: result.httpDetails,\n            result: decodeReturnValue(func.retTypes, result.reply.arg)\n          } : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingStrategyFactory\n      } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const {\n        requestId,\n        response\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid\n      });\n      if (!response.ok || response.body /* IC-1462 */) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n      const pollStrategy = pollingStrategyFactory();\n      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      if (responseBytes !== undefined) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: decodeReturnValue(func.retTypes, responseBytes)\n        } : decodeReturnValue(func.retTypes, responseBytes);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: undefined\n        } : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n  const handler = (...args) => caller({}, ...args);\n  handler.withOptions = options => (...args) => caller(options, ...args);\n  return handler;\n}\n/**\n * Create a management canister actor\n * @param config\n */\nexport function getManagementCanister(config) {\n  function transform(_methodName, args, _callConfig) {\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id);\n    }\n    return {\n      effectiveCanisterId\n    };\n  }\n  return Actor.createActor(managementCanisterIdl, Object.assign(Object.assign(Object.assign({}, config), {\n    canisterId: Principal.fromHex('')\n  }), {\n    callTransform: transform,\n    queryTransform: transform\n  }));\n}","map":{"version":3,"names":["Buffer","getDefaultAgent","ReplicaRejectCode","AgentError","IDL","pollForResponse","strategy","Principal","toHex","managementCanisterIdl","ActorCallError","constructor","canisterId","methodName","type","props","toText","Object","getOwnPropertyNames","map","n","JSON","stringify","join","QueryCallRejectedError","result","Status","status","Code","_a","reject_code","Message","reject_message","UpdateCallRejectedError","requestId","response","assign","body","error_code","String","toString","statusText","CanisterInstallMode","metadataSymbol","Symbol","for","Actor","metadata","freeze","agentOf","actor","config","agent","interfaceOf","service","canisterIdOf","from","install","fields","mode","undefined","Install","arg","Uint8Array","wasmModule","module","fromText","getManagementCanister","install_code","wasm_module","canister_id","createCanister","provisional_create_canister_with_cycles","amount","settings","createAndInstallCanister","interfaceFactory","createActor","createActorClass","options","CanisterActor","DEFAULT_ACTOR_CONFIG","func","_fields","httpDetails","annotations","push","ACTOR_METHOD_WITH_HTTP_DETAILS","_createActorMethod","blsVerify","configuration","createActorWithHttpDetails","decodeReturnValue","types","msg","returnValues","decode","length","pollingStrategyFactory","defaultStrategy","caller","includes","args","_b","queryTransform","call","cid","encode","argTypes","query","retTypes","reply","callTransform","effectiveCanisterId","ecid","ok","pollStrategy","responseBytes","shouldIncludeHttpDetails","Error","handler","withOptions","transform","_methodName","_callConfig","first","fromHex"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\actor.ts"],"sourcesContent":["import { Buffer } from 'buffer/';\nimport {\n  Agent,\n  getDefaultAgent,\n  HttpDetailsResponse,\n  QueryResponseRejected,\n  QueryResponseStatus,\n  ReplicaRejectCode,\n  SubmitResponse,\n} from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, PollStrategyFactory, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { RequestId } from './request_id';\nimport { toHex } from './utils/buffer';\nimport { CreateCertificateOptions } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nimport _SERVICE from './canisters/management_service';\n\nexport class ActorCallError extends AgentError {\n  constructor(\n    public readonly canisterId: Principal,\n    public readonly methodName: string,\n    public readonly type: 'query' | 'update',\n    public readonly props: Record<string, string>,\n  ) {\n    super(\n      [\n        `Call failed:`,\n        `  Canister: ${canisterId.toText()}`,\n        `  Method: ${methodName} (${type})`,\n        ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n      ].join('\\n'),\n    );\n  }\n}\n\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly result: QueryResponseRejected,\n  ) {\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: ReplicaRejectCode[result.reject_code] ?? `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message,\n    });\n  }\n}\n\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly requestId: RequestId,\n    public readonly response: SubmitResponse['response'],\n  ) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      ...(response.body\n        ? {\n            ...(response.body.error_code\n              ? {\n                  'Error code': response.body.error_code,\n                }\n              : {}),\n            'Reject code': String(response.body.reject_code),\n            'Reject message': response.body.reject_message,\n          }\n        : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n          }),\n    });\n  }\n}\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * A polling strategy factory that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   */\n  pollingStrategyFactory?: PollStrategyFactory;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport enum CanisterInstallMode {\n  Install = 'install',\n  Reinstall = 'reinstall',\n  Upgrade = 'upgrade',\n}\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static async install(\n    fields: {\n      module: ArrayBuffer;\n      mode?: CanisterInstallMode;\n      arg?: ArrayBuffer;\n    },\n    config: ActorConfig,\n  ): Promise<void> {\n    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId =\n      typeof config.canisterId === 'string'\n        ? Principal.fromText(config.canisterId)\n        : config.canisterId;\n\n    await getManagementCanister(config).install_code({\n      mode: { [mode]: null } as any,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n    });\n  }\n\n  public static async createCanister(config?: CallConfig): Promise<Principal> {\n    const { canister_id: canisterId } = await getManagementCanister(\n      config || {},\n    ).provisional_create_canister_with_cycles({ amount: [], settings: [] });\n\n    return canisterId;\n  }\n\n  public static async createAndInstallCanister(\n    interfaceFactory: IDL.InterfaceFactory,\n    fields: {\n      module: ArrayBuffer;\n      arg?: ArrayBuffer;\n    },\n    config?: CallConfig,\n  ): Promise<ActorSubclass> {\n    const canisterId = await this.createCanister(config);\n    await this.install(\n      {\n        ...fields,\n      },\n      { ...config, canisterId },\n    );\n\n    return this.createActor(interfaceFactory, { ...config, canisterId });\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId)\n          throw new AgentError(\n            `Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n          );\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw new AgentError(\n        `Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n      );\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: ArrayBuffer) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, { methodName, arg });\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails: result.httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const { requestId, response } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n      });\n\n      if (!response.ok || response.body /* IC-1462 */) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n\n      const pollStrategy = pollingStrategyFactory();\n      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n\n      if (responseBytes !== undefined) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: decodeReturnValue(func.retTypes, responseBytes),\n            }\n          : decodeReturnValue(func.retTypes, responseBytes);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n\nexport type ManagementCanisterRecord = _SERVICE;\n\n/**\n * Create a management canister actor\n * @param config\n */\nexport function getManagementCanister(config: CallConfig): ActorSubclass<ManagementCanisterRecord> {\n  function transform(_methodName: string, args: unknown[], _callConfig: CallConfig) {\n    const first = args[0] as any;\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id as unknown);\n    }\n    return { effectiveCanisterId };\n  }\n\n  return Actor.createActor<ManagementCanisterRecord>(managementCanisterIdl, {\n    ...config,\n    canisterId: Principal.fromHex(''),\n    ...{\n      callTransform: transform,\n      queryTransform: transform,\n    },\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}