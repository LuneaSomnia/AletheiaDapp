{"ast":null,"code":"import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\nconst NodeId = {\n  Empty: 0,\n  Fork: 1,\n  Labeled: 2,\n  Leaf: 3,\n  Pruned: 4\n};\nexport { NodeId };\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree) {\n  const indent = s => s.split('\\n').map(x => '  ' + x).join('\\n');\n  function labelToString(label) {\n    const decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n  switch (tree[0]) {\n    case NodeId.Empty:\n      return '()';\n    case NodeId.Fork:\n      {\n        if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n          const left = hashTreeToString(tree[1]);\n          const right = hashTreeToString(tree[2]);\n          return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n        } else {\n          throw new Error('Invalid tree structure for fork');\n        }\n      }\n    case NodeId.Labeled:\n      {\n        if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n          const label = labelToString(tree[1]);\n          const sub = hashTreeToString(tree[2]);\n          return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n        } else {\n          throw new Error('Invalid tree structure for labeled');\n        }\n      }\n    case NodeId.Leaf:\n      {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for leaf');\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `leaf(...${tree[1].byteLength} bytes)`;\n      }\n    case NodeId.Pruned:\n      {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for pruned');\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n      }\n    default:\n      {\n        return `unknown(${JSON.stringify(tree[0])})`;\n      }\n  }\n}\nfunction isBufferEqual(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport class Certificate {\n  constructor(certificate, _rootKey, _canisterId, _blsVerify,\n  // Default to 5 minutes\n  _maxAgeInMinutes = 5) {\n    this._rootKey = _rootKey;\n    this._canisterId = _canisterId;\n    this._blsVerify = _blsVerify;\n    this._maxAgeInMinutes = _maxAgeInMinutes;\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  static async create(options) {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n    await cert.verify();\n    return cert;\n  }\n  lookup(path) {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookupResultToBuffer(lookup_path(path, this.cert.tree));\n  }\n  lookup_label(label) {\n    return this.lookup([label]);\n  }\n  async verify() {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n    const lookupTime = this.lookup(['time']);\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n    const certTime = decodeTime(lookupTime);\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    }\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n  async _checkDelegationAndGetKey(d) {\n    if (!d) {\n      return this._rootKey;\n    }\n    const cert = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity\n    });\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n  }\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(result) {\n  if (result instanceof ArrayBuffer) {\n    return result;\n  } else if (result instanceof Uint8Array) {\n    return result.buffer;\n  }\n  return undefined;\n}\n/**\n * @param t\n */\nexport async function reconstruct(t) {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeId.Pruned:\n      return t[1];\n    case NodeId.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n    case NodeId.Labeled:\n      return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n    case NodeId.Fork:\n      return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n    default:\n      throw new Error('unreachable');\n  }\n}\nfunction domain_sep(s) {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeId.Leaf:\n        {\n          // should not be undefined\n          if (!tree[1]) throw new Error('Invalid tree structure for leaf');\n          if (tree[1] instanceof ArrayBuffer) {\n            return tree[1];\n          } else if (tree[1] instanceof Uint8Array) {\n            return tree[1].buffer;\n          } else return tree[1];\n        }\n      case NodeId.Fork:\n        {\n          return tree;\n        }\n      default:\n        {\n          return tree;\n        }\n    }\n  }\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t) {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return [];\n    case NodeId.Fork:\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n    default:\n      return [t];\n  }\n}\nfunction find_label(l, trees) {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === NodeId.Labeled) {\n      const p = t[1];\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params) {\n  const {\n    canisterId,\n    subnetId,\n    tree\n  } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n  if (!rangeLookup || !(rangeLookup instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n  const ranges_arr = cbor.decode(rangeLookup);\n  const ranges = ranges_arr.map(v => [Principal.fromUint8Array(v[0]), Principal.fromUint8Array(v[1])]);\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n  return canisterInRange;\n}","map":{"version":3,"names":["cbor","AgentError","hash","concat","fromHex","toHex","Principal","bls","decodeTime","CertificateVerificationError","constructor","reason","NodeId","Empty","Fork","Labeled","Leaf","Pruned","hashTreeToString","tree","indent","s","split","map","x","join","labelToString","label","decoder","TextDecoder","undefined","fatal","JSON","stringify","decode","e","byteLength","Array","ArrayBuffer","left","right","Error","sub","isArray","Uint8Array","isBufferEqual","a","b","a8","b8","i","length","Certificate","certificate","_rootKey","_canisterId","_blsVerify","_maxAgeInMinutes","cert","create","options","blsVerify","rootKey","canisterId","maxAgeInMinutes","verify","lookup","path","lookupResultToBuffer","lookup_path","lookup_label","rootHash","reconstruct","derKey","_checkDelegationAndGetKey","delegation","sig","signature","key","extractDER","msg","domain_sep","sigVer","lookupTime","FIVE_MINUTES_IN_MSEC","MAX_AGE_IN_MSEC","now","Date","earliestCertificateTime","fiveMinutesFromNow","certTime","getTime","toISOString","err","d","Infinity","canisterInRange","check_canister_ranges","subnetId","fromUint8Array","subnet_id","publicKeyLookup","DER_PREFIX","KEY_LENGTH","buf","expectedLength","TypeError","prefix","slice","result","buffer","t","len","str","TextEncoder","encode","find_label","flatten_forks","l","trees","p","params","rangeLookup","toUint8Array","ranges_arr","ranges","v","some","r","ltEq","gtEq"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\certificate.ts"],"sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\nexport interface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nconst NodeId = {\n  Empty: 0,\n  Fork: 1,\n  Labeled: 2,\n  Leaf: 3,\n  Pruned: 4,\n};\n\nexport type NodeIdType = typeof NodeId[keyof typeof NodeId];\n\nexport { NodeId };\n\nexport type HashTree =\n  | [typeof NodeId.Empty]\n  | [typeof NodeId.Fork, HashTree, HashTree]\n  | [typeof NodeId.Labeled, ArrayBuffer, HashTree]\n  | [typeof NodeId.Leaf, ArrayBuffer]\n  | [typeof NodeId.Pruned, ArrayBuffer];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeId.Empty:\n      return '()';\n    case NodeId.Fork: {\n      if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for fork');\n      }\n    }\n    case NodeId.Labeled: {\n      if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for labeled');\n      }\n    }\n    case NodeId.Leaf: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for leaf');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeId.Pruned: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for pruned');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, any> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean>;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n}\n\ntype MetricsResult = number | bigint | Map<number, number | bigint> | undefined;\n\nexport class Certificate {\n  private readonly cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n      options.maxAgeInMinutes,\n    );\n\n    await cert.verify();\n    return cert;\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): ArrayBuffer | undefined {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookupResultToBuffer(lookup_path(path, this.cert.tree));\n  }\n\n  public lookup_label(label: ArrayBuffer): ArrayBuffer | HashTree | undefined {\n    return this.lookup([label]);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = this.lookup(['time']);\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n    const certTime = decodeTime(lookupTime);\n\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(\n        `Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError(\n        'Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert: Certificate = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity,\n    });\n\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree,\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(\n  result: ArrayBuffer | HashTree | undefined,\n): ArrayBuffer | undefined {\n  if (result instanceof ArrayBuffer) {\n    return result;\n  } else if (result instanceof Uint8Array) {\n    return result.buffer;\n  }\n  return undefined;\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeId.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeId.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeId.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeId.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(\n  path: Array<ArrayBuffer | string>,\n  tree: HashTree,\n): ArrayBuffer | HashTree | undefined {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeId.Leaf: {\n        // should not be undefined\n        if (!tree[1]) throw new Error('Invalid tree structure for leaf');\n        if (tree[1] instanceof ArrayBuffer) {\n          return tree[1];\n        } else if (tree[1] instanceof Uint8Array) {\n          return tree[1].buffer;\n        } else return tree[1];\n      }\n      case NodeId.Fork: {\n        return tree;\n      }\n      default: {\n        return tree;\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\n\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return [];\n    case NodeId.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\n\nfunction find_label(l: ArrayBuffer, trees: HashTree[]): HashTree | undefined {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === NodeId.Labeled) {\n      const p = t[1] as ArrayBuffer;\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}\n\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params: {\n  canisterId: Principal;\n  subnetId: Principal;\n  tree: HashTree;\n}): boolean {\n  const { canisterId, subnetId, tree } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n\n  if (!rangeLookup || !(rangeLookup instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n\n  const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup);\n  const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n    Principal.fromUint8Array(v[0]),\n    Principal.fromUint8Array(v[1]),\n  ]);\n\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n\n  return canisterInRange;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}