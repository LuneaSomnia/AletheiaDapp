{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey, _Ed25519KeyIdentity_publicKey, _Ed25519KeyIdentity_privateKey;\nimport { SignIdentity, uint8ToBuf, ED25519_OID, unwrapDER, wrapDER, fromHex, toHex } from '@dfinity/agent';\nimport { ed25519 } from '@noble/curves/ed25519';\nexport class Ed25519PublicKey {\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(key) {\n    _Ed25519PublicKey_rawKey.set(this, void 0);\n    _Ed25519PublicKey_derKey.set(this, void 0);\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n    __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n  }\n  static from(key) {\n    return this.fromDer(key.toDer());\n  }\n  static fromRaw(rawKey) {\n    return new Ed25519PublicKey(rawKey);\n  }\n  static fromDer(derKey) {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n  static derEncode(publicKey) {\n    return wrapDER(publicKey, ED25519_OID).buffer;\n  }\n  static derDecode(key) {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n  get rawKey() {\n    return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n  }\n  get derKey() {\n    return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n  }\n  toDer() {\n    return this.derKey;\n  }\n  toRaw() {\n    return this.rawKey;\n  }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\nexport class Ed25519KeyIdentity extends SignIdentity {\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(publicKey, privateKey) {\n    super();\n    _Ed25519KeyIdentity_publicKey.set(this, void 0);\n    _Ed25519KeyIdentity_privateKey.set(this, void 0);\n    __classPrivateFieldSet(this, _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), \"f\");\n    __classPrivateFieldSet(this, _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), \"f\");\n  }\n  static generate(seed = new Uint8Array(32)) {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) sk[i] = new Uint8Array(seed)[i];\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n  static fromParsedJson(obj) {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHex(publicKeyDer)), fromHex(privateKeyRaw));\n  }\n  static fromJSON(json) {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n  static fromKeyPair(publicKey, privateKey) {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n  static fromSecretKey(secretKey) {\n    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n  /**\n   * Serialize this key to JSON.\n   */\n  toJSON() {\n    return [toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\").toDer()), toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"))];\n  }\n  /**\n   * Return a copy of the key pair.\n   */\n  getKeyPair() {\n    return {\n      secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"),\n      publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\")\n    };\n  }\n  /**\n   * Return the public key.\n   */\n  getPublicKey() {\n    return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\");\n  }\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  async sign(challenge) {\n    const blob = new Uint8Array(challenge);\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = uint8ToBuf(ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\").slice(0, 32)));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined\n    });\n    return signature;\n  }\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  static verify(sig, msg, pk) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = fromHex(x);\n      }\n      if (x instanceof Uint8Array) {\n        x = x.buffer;\n      }\n      return new Uint8Array(x);\n    });\n    return ed25519.verify(message, signature, publicKey);\n  }\n}\n_Ed25519KeyIdentity_publicKey = new WeakMap(), _Ed25519KeyIdentity_privateKey = new WeakMap();","map":{"version":3,"names":["SignIdentity","uint8ToBuf","ED25519_OID","unwrapDER","wrapDER","fromHex","toHex","ed25519","Ed25519PublicKey","constructor","key","_Ed25519PublicKey_rawKey","set","_Ed25519PublicKey_derKey","byteLength","RAW_KEY_LENGTH","Error","__classPrivateFieldSet","derEncode","from","fromDer","toDer","fromRaw","rawKey","derKey","derDecode","publicKey","buffer","unwrapped","length","__classPrivateFieldGet","toRaw","Ed25519KeyIdentity","privateKey","_Ed25519KeyIdentity_publicKey","_Ed25519KeyIdentity_privateKey","Uint8Array","generate","seed","utils","randomPrivateKey","sk","i","pk","getPublicKey","fromKeyPair","fromParsedJson","obj","publicKeyDer","privateKeyRaw","fromJSON","json","parsed","JSON","parse","Array","isArray","stringify","fromSecretKey","secretKey","toJSON","getKeyPair","sign","challenge","blob","signature","slice","Object","defineProperty","enumerable","value","undefined","verify","sig","msg","message","map","x"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\identity\\src\\identity\\ed25519.ts"],"sourcesContent":["import {\n  DerEncodedPublicKey,\n  KeyPair,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  uint8ToBuf,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n  fromHex,\n  toHex,\n} from '@dfinity/agent';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport class Ed25519PublicKey implements PublicKey {\n  public static from(key: PublicKey): Ed25519PublicKey {\n    return this.fromDer(key.toDer());\n  }\n\n  public static fromRaw(rawKey: ArrayBuffer): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    return wrapDER(publicKey, ED25519_OID).buffer as DerEncodedPublicKey;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: ArrayBuffer;\n\n  public get rawKey(): ArrayBuffer {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n\nexport class Ed25519KeyIdentity extends SignIdentity {\n  public static generate(seed = new Uint8Array(32)): Ed25519KeyIdentity {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) sk[i] = new Uint8Array(seed)[i];\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(fromHex(publicKeyDer) as DerEncodedPublicKey),\n      fromHex(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: ArrayBuffer, privateKey: ArrayBuffer): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: ArrayBuffer): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: ArrayBuffer) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = new Uint8Array(privateKey);\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [toHex(this.#publicKey.toDer()), toHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const blob = new Uint8Array(challenge);\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = uint8ToBuf(ed25519.sign(blob, this.#privateKey.slice(0, 32)));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = fromHex(x);\n      }\n      if (x instanceof Uint8Array) {\n        x = x.buffer;\n      }\n      return new Uint8Array(x);\n    });\n    return ed25519.verify(message, signature, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}