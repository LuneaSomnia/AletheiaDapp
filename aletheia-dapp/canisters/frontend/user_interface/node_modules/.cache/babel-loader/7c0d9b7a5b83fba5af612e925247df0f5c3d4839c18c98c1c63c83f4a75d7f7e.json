{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_verifyQueryResponse;\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { hashOfMap, requestIdOf } from '../../request_id';\nimport { concat, fromHex } from '../../utils/buffer';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport { makeNonce, SubmitRequestType } from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { request } from '../../canisterStatus';\nimport { CertificateVerificationError } from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nexport * from './transforms';\nexport { makeNonce } from './types';\nexport var RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n  RequestStatusResponseStatus[\"Received\"] = \"received\";\n  RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n  RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n  RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n  RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n  RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nfunction getDefaultFetch() {\n  let defaultFetch;\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent {\n  constructor(options = {}) {\n    this.rootKey = fromHex(IC_ROOT_KEY);\n    this._timeDiffMsecs = 0;\n    this._rootKeyFetched = false;\n    this._isAgent = true;\n    _HttpAgent_queryPipeline.set(this, []);\n    _HttpAgent_updatePipeline.set(this, []);\n    _HttpAgent_subnetKeys.set(this, new ExpirableMap({\n      expirationTime: 5 * 60 * 1000 // 5 minutes\n    }));\n    _HttpAgent_verifyQuerySignatures.set(this, true);\n    /**\n     * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n     * @param queryResponse - The response from the query\n     * @param subnetStatus - The subnet status, including all node keys\n     * @returns ApiQueryResponse\n     */\n    _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n      if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n        // This should not be called if the user has disabled verification\n        return queryResponse;\n      }\n      if (!subnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      const {\n        status,\n        signatures = [],\n        requestId\n      } = queryResponse;\n      const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n      for (const sig of signatures) {\n        const {\n          timestamp,\n          identity\n        } = sig;\n        const nodeId = Principal.fromUint8Array(identity).toText();\n        let hash;\n        // Hash is constructed differently depending on the status\n        if (status === 'replied') {\n          const {\n            reply\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reply: reply,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else if (status === 'rejected') {\n          const {\n            reject_code,\n            reject_message,\n            error_code\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reject_code: reject_code,\n            reject_message: reject_message,\n            error_code: error_code,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else {\n          throw new Error(`Unknown status: ${status}`);\n        }\n        const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n        // FIX: check for match without verifying N times\n        const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n        if (!pubKey) {\n          throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n        }\n        const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n        const valid = ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n        if (valid) return queryResponse;\n        throw new CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n      }\n      return queryResponse;\n    });\n    if (options.source) {\n      if (!(options.source instanceof HttpAgent)) {\n        throw new Error(\"An Agent's source can only be another HttpAgent\");\n      }\n      this._identity = options.source._identity;\n      this._fetch = options.source._fetch;\n      this._host = options.source._host;\n      this._credentials = options.source._credentials;\n    } else {\n      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n      this._fetchOptions = options.fetchOptions;\n      this._callOptions = options.callOptions;\n    }\n    if (options.host !== undefined) {\n      if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n        this._host = new URL(window.location.protocol + '//' + options.host);\n      } else {\n        this._host = new URL(options.host);\n      }\n    } else if (options.source !== undefined) {\n      // Safe to ignore here.\n      this._host = options.source._host;\n    } else {\n      const location = typeof window !== 'undefined' ? window.location : undefined;\n      if (!location) {\n        this._host = new URL('https://icp-api.io');\n        console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');\n      }\n      // Mainnet and local will have the api route available\n      const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n      const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n      let knownHost;\n      if (hostname && typeof hostname === 'string') {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n      if (location && knownHost) {\n        // If the user is on a boundary-node provided host, we can use the same host for the agent\n        this._host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n      } else {\n        this._host = new URL('https://icp-api.io');\n        console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');\n      }\n    }\n    if (options.verifyQuerySignatures !== undefined) {\n      __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n    }\n    // Default is 3, only set from option if greater or equal to 0\n    this._retryTimes = options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;\n    // Rewrite to avoid redirects\n    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this._host.hostname = IC0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this._host.hostname = ICP0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this._host.hostname = ICP_API_DOMAIN;\n    }\n    if (options.credentials) {\n      const {\n        name,\n        password\n      } = options.credentials;\n      this._credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n  }\n  isLocal() {\n    const hostname = this._host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n  addTransform(type, fn, priority = fn.priority || 0) {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    }\n  }\n  async getPrincipal() {\n    if (!this._identity) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    return (await this._identity).getPrincipal();\n  }\n  async call(canisterId, options, identity) {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;\n    const sender = id.getPrincipal() || Principal.anonymous();\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);\n    }\n    const submit = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest = await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, this._credentials ? {\n          Authorization: 'Basic ' + btoa(this._credentials)\n        } : {})\n      },\n      endpoint: \"call\" /* Endpoint.Call */,\n      body: submit\n    });\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n    const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), {\n      body\n    })));\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n    const responseBuffer = await response.arrayBuffer();\n    const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null;\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        body: responseBody,\n        headers: httpHeadersTransform(response.headers)\n      }\n    };\n  }\n  async _requestAndRetry(request, tries = 0) {\n    let response;\n    try {\n      response = await request();\n    } catch (error) {\n      if (this._retryTimes > tries) {\n        console.warn(`Caught exception while attempting to make request:\\n` + `  ${error}\\n` + `  Retrying request.`);\n        return await this._requestAndRetry(request, tries + 1);\n      }\n      throw error;\n    }\n    if (response.ok) {\n      return response;\n    }\n    const responseText = await response.clone().text();\n    const errorMessage = `Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${responseText}\\n`;\n    if (this._retryTimes > tries) {\n      console.warn(errorMessage + `  Retrying request.`);\n      return await this._requestAndRetry(request, tries + 1);\n    }\n    throw new AgentHTTPResponseError(errorMessage, {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers)\n    });\n  }\n  async query(canisterId, fields, identity) {\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await this._identity);\n      if (!id) {\n        throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n      }\n      const canister = Principal.from(canisterId);\n      const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n      const request = {\n        request_type: \"query\" /* ReadRequestType.Query */,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      };\n      const requestId = await requestIdOf(request);\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: Object.assign({\n            'Content-Type': 'application/cbor'\n          }, this._credentials ? {\n            Authorization: 'Basic ' + btoa(this._credentials)\n          } : {})\n        },\n        endpoint: \"read\" /* Endpoint.Query */,\n        body: request\n      });\n      // Apply transform for identity.\n      transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));\n      const body = cbor.encode(transformedRequest.body);\n      const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), {\n        body\n      })));\n      const queryResponse = cbor.decode(await response.arrayBuffer());\n      return Object.assign(Object.assign({}, queryResponse), {\n        httpDetails: {\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          headers: httpHeadersTransform(response.headers)\n        },\n        requestId\n      });\n    };\n    const getSubnetStatus = async () => {\n      if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n        return undefined;\n      }\n      const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(canisterId.toString());\n      return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n    };\n    // Make query and fetch subnet keys in parallel\n    const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    // Skip verification if the user has disabled it\n    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n      return query;\n    }\n    try {\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, query, subnetStatus);\n    } catch (_) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      console.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n      await this.fetchSubnetKeys(canisterId.toString());\n      const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, query, updatedSubnetStatus);\n    }\n  }\n  async createReadStateRequest(fields, identity) {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, this._credentials ? {\n          Authorization: 'Basic ' + btoa(this._credentials)\n        } : {})\n      },\n      endpoint: \"read_state\" /* Endpoint.ReadState */,\n      body: {\n        request_type: \"read_state\" /* ReadRequestType.ReadState */,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      }\n    });\n    // Apply transform for identity.\n    return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n  }\n  async readState(canisterId, fields, identity,\n  // eslint-disable-next-line\n  request) {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const transformedRequest = request !== null && request !== void 0 ? request : await this.createReadStateRequest(fields, identity);\n    const body = cbor.encode(transformedRequest.body);\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), {\n      body\n    })));\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n    return cbor.decode(await response.arrayBuffer());\n  }\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  async syncTime(canisterId) {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        console.log('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time']\n      });\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this._timeDiffMsecs = Number(replicaTime) - Number(callTime);\n      }\n    } catch (error) {\n      console.error('Caught exception while attempting to sync time:', error);\n    }\n  }\n  async status() {\n    const headers = this._credentials ? {\n      Authorization: 'Basic ' + btoa(this._credentials)\n    } : {};\n    const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({\n      headers\n    }, this._fetchOptions)));\n    return cbor.decode(await response.arrayBuffer());\n  }\n  async fetchRootKey() {\n    if (!this._rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = (await this.status()).root_key;\n      this._rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n  invalidateIdentity() {\n    this._identity = null;\n  }\n  replaceIdentity(identity) {\n    this._identity = Promise.resolve(identity);\n  }\n  async fetchSubnetKeys(canisterId) {\n    const effectiveCanisterId = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this\n    });\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n      return subnetResponse;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n  _transform(request) {\n    let p = Promise.resolve(request);\n    if (request.endpoint === \"call\" /* Endpoint.Call */) {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n    return p;\n  }\n}\n_HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap();","map":{"version":3,"names":["Principal","AgentError","AnonymousIdentity","cbor","hashOfMap","requestIdOf","concat","fromHex","Expiry","httpHeadersTransform","makeNonceTransform","makeNonce","SubmitRequestType","AgentHTTPResponseError","request","CertificateVerificationError","ed25519","ExpirableMap","Ed25519PublicKey","RequestStatusResponseStatus","DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS","IC_ROOT_KEY","IC0_DOMAIN","IC0_SUB_DOMAIN","ICP0_DOMAIN","ICP0_SUB_DOMAIN","ICP_API_DOMAIN","ICP_API_SUB_DOMAIN","HttpDefaultFetchError","constructor","message","IdentityInvalidError","getDefaultFetch","defaultFetch","window","fetch","bind","global","self","HttpAgent","options","rootKey","_timeDiffMsecs","_rootKeyFetched","_isAgent","_HttpAgent_queryPipeline","set","_HttpAgent_updatePipeline","_HttpAgent_subnetKeys","expirationTime","_HttpAgent_verifyQuerySignatures","_HttpAgent_verifyQueryResponse","queryResponse","subnetStatus","__classPrivateFieldGet","status","signatures","requestId","domainSeparator","TextEncoder","encode","sig","timestamp","identity","nodeId","fromUint8Array","toText","hash","reply","BigInt","request_id","reject_code","reject_message","error_code","Error","separatorWithHash","Uint8Array","pubKey","nodeKeys","get","rawKey","fromDer","valid","verify","signature","source","_identity","_fetch","_host","_credentials","_fetchOptions","fetchOptions","_callOptions","callOptions","host","undefined","match","URL","location","protocol","console","warn","knownHosts","hostname","knownHost","find","endsWith","port","verifyQuerySignatures","__classPrivateFieldSet","_retryTimes","retryTimes","credentials","name","password","Promise","resolve","addTransform","useQueryNonces","isLocal","type","fn","priority","i","findIndex","x","splice","length","Object","assign","getPrincipal","call","canisterId","id","canister","from","ecid","effectiveCanisterId","sender","anonymous","ingress_expiry","Math","abs","submit","request_type","Call","canister_id","method_name","methodName","arg","transformedRequest","_transform","body","method","headers","Authorization","btoa","endpoint","transformRequest","_requestAndRetry","response","all","responseBuffer","arrayBuffer","responseBody","byteLength","decode","ok","statusText","tries","error","responseText","clone","text","errorMessage","query","fields","makeQuery","httpDetails","getSubnetStatus","toString","fetchSubnetKeys","_","delete","updatedSubnetStatus","createReadStateRequest","paths","readState","fromText","syncTime","CanisterStatus","callTime","Date","now","log","agent","replicaTime","Number","fetchRootKey","root_key","invalidateIdentity","replaceIdentity","subnetResponse","p","then","r","r2"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\agent\\http\\index.ts"],"sourcesContent":["import { JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity, Identity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { hashOfMap, requestIdOf } from '../../request_id';\nimport { concat, fromHex } from '../../utils/buffer';\nimport {\n  Agent,\n  ApiQueryResponse,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from '../api';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport {\n  CallRequest,\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpAgentSubmitRequest,\n  makeNonce,\n  QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n} from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { SubnetStatus, request } from '../../canisterStatus';\nimport { CertificateVerificationError } from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\n\nexport * from './transforms';\nexport { Nonce, makeNonce } from './types';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nclass HttpDefaultFetchError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // Another HttpAgent to inherit configuration (pipeline and fetch) of. This\n  // is only used at construction.\n  source?: HttpAgent;\n\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Adds a unique {@link Nonce} with each query.\n   * Enabling will prevent queries from being answered with a cached response.\n   *\n   * @example\n   * const agent = new HttpAgent({ useQueryNonces: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  useQueryNonces?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n  /**\n   * Whether the agent should verify signatures signed by node keys on query responses. Increases security, but adds overhead and must make a separate request to cache the node keys for the canister's subnet.\n   * @default true\n   */\n  verifyQuerySignatures?: boolean;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError(\n    'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n  );\n}\n\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent implements Agent {\n  public rootKey = fromHex(IC_ROOT_KEY);\n  private _identity: Promise<Identity> | null;\n  private readonly _fetch: typeof fetch;\n  private readonly _fetchOptions?: Record<string, unknown>;\n  private readonly _callOptions?: Record<string, unknown>;\n  private _timeDiffMsecs = 0;\n  private readonly _host: URL;\n  private readonly _credentials: string | undefined;\n  private _rootKeyFetched = false;\n  private readonly _retryTimes; // Retry requests N times before erroring by default\n  public readonly _isAgent = true;\n\n  #queryPipeline: HttpAgentRequestTransformFn[] = [];\n  #updatePipeline: HttpAgentRequestTransformFn[] = [];\n\n  #subnetKeys: ExpirableMap<string, SubnetStatus> = new ExpirableMap({\n    expirationTime: 5 * 60 * 1000, // 5 minutes\n  });\n  #verifyQuerySignatures = true;\n\n  constructor(options: HttpAgentOptions = {}) {\n    if (options.source) {\n      if (!(options.source instanceof HttpAgent)) {\n        throw new Error(\"An Agent's source can only be another HttpAgent\");\n      }\n      this._identity = options.source._identity;\n      this._fetch = options.source._fetch;\n      this._host = options.source._host;\n      this._credentials = options.source._credentials;\n    } else {\n      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n      this._fetchOptions = options.fetchOptions;\n      this._callOptions = options.callOptions;\n    }\n    if (options.host !== undefined) {\n      if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n        this._host = new URL(window.location.protocol + '//' + options.host);\n      } else {\n        this._host = new URL(options.host);\n      }\n    } else if (options.source !== undefined) {\n      // Safe to ignore here.\n      this._host = options.source._host;\n    } else {\n      const location = typeof window !== 'undefined' ? window.location : undefined;\n      if (!location) {\n        this._host = new URL('https://icp-api.io');\n        console.warn(\n          'Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.',\n        );\n      }\n      // Mainnet and local will have the api route available\n      const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n      const hostname = location?.hostname;\n      let knownHost;\n      if (hostname && typeof hostname === 'string') {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n\n      if (location && knownHost) {\n        // If the user is on a boundary-node provided host, we can use the same host for the agent\n        this._host = new URL(\n          `${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`,\n        );\n      } else {\n        this._host = new URL('https://icp-api.io');\n        console.warn(\n          'Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.',\n        );\n      }\n    }\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3, only set from option if greater or equal to 0\n    this._retryTimes =\n      options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;\n    // Rewrite to avoid redirects\n    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this._host.hostname = IC0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this._host.hostname = ICP0_DOMAIN;\n    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this._host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this._credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this._host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n\n  public addTransform(\n    type: 'update' | 'query',\n    fn: HttpAgentRequestTransformFn,\n    priority = fn.priority || 0,\n  ): void {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(\n        i >= 0 ? i : this.#updatePipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(\n        i >= 0 ? i : this.#queryPipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this._identity) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    return (await this._identity).getPrincipal();\n  }\n\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n\n    const sender: Principal = id.getPrincipal() || Principal.anonymous();\n\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this._timeDiffMsecs) > 1_000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);\n    }\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n    const request = this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), {\n        ...this._callOptions,\n        ...transformedRequest.request,\n        body,\n      }),\n    );\n\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n\n    const responseBuffer = await response.arrayBuffer();\n    const responseBody = (\n      response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null\n    ) as SubmitResponse['response']['body'];\n\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        body: responseBody,\n        headers: httpHeadersTransform(response.headers),\n      },\n    };\n  }\n\n  private async _requestAndRetry(request: () => Promise<Response>, tries = 0): Promise<Response> {\n    let response: Response;\n    try {\n      response = await request();\n    } catch (error) {\n      if (this._retryTimes > tries) {\n        console.warn(\n          `Caught exception while attempting to make request:\\n` +\n            `  ${error}\\n` +\n            `  Retrying request.`,\n        );\n        return await this._requestAndRetry(request, tries + 1);\n      }\n      throw error;\n    }\n    if (response.ok) {\n      return response;\n    }\n\n    const responseText = await response.clone().text();\n    const errorMessage =\n      `Server returned an error:\\n` +\n      `  Code: ${response.status} (${response.statusText})\\n` +\n      `  Body: ${responseText}\\n`;\n\n    if (this._retryTimes > tries) {\n      console.warn(errorMessage + `  Retrying request.`);\n      return await this._requestAndRetry(request, tries + 1);\n    }\n\n    throw new AgentHTTPResponseError(errorMessage, {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers),\n    });\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse> {\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await this._identity);\n      if (!id) {\n        throw new IdentityInvalidError(\n          \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n        );\n      }\n\n      const canister = Principal.from(canisterId);\n      const sender = id?.getPrincipal() || Principal.anonymous();\n\n      const request: QueryRequest = {\n        request_type: ReadRequestType.Query,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      };\n\n      const requestId = await requestIdOf(request);\n\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest: any = await this._transform({\n        request: {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/cbor',\n            ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n          },\n        },\n        endpoint: Endpoint.Query,\n        body: request,\n      });\n\n      // Apply transform for identity.\n      transformedRequest = await id?.transformRequest(transformedRequest);\n\n      const body = cbor.encode(transformedRequest.body);\n\n      const response = await this._requestAndRetry(() =>\n        this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), {\n          ...this._fetchOptions,\n          ...transformedRequest.request,\n          body,\n        }),\n      );\n\n      const queryResponse: QueryResponse = cbor.decode(await response.arrayBuffer());\n\n      return {\n        ...queryResponse,\n        httpDetails: {\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          headers: httpHeadersTransform(response.headers),\n        },\n        requestId,\n      };\n    };\n\n    const getSubnetStatus = async (): Promise<SubnetStatus | void> => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(canisterId.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(canisterId.toString());\n      return this.#subnetKeys.get(canisterId.toString());\n    };\n    // Make query and fetch subnet keys in parallel\n    const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    // Skip verification if the user has disabled it\n    if (!this.#verifyQuerySignatures) {\n      return query;\n    }\n    try {\n      return this.#verifyQueryResponse(query, subnetStatus);\n    } catch (_) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      console.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      this.#subnetKeys.delete(canisterId.toString());\n      await this.fetchSubnetKeys(canisterId.toString());\n\n      const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      return this.#verifyQueryResponse(query, updatedSubnetStatus);\n    }\n  }\n\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse = (\n    queryResponse: ApiQueryResponse,\n    subnetStatus: SubnetStatus | void,\n  ): ApiQueryResponse => {\n    if (this.#verifyQuerySignatures === false) {\n      // This should not be called if the user has disabled verification\n      return queryResponse;\n    }\n    if (!subnetStatus) {\n      throw new CertificateVerificationError(\n        'Invalid signature from replica signed query: no matching node key found.',\n      );\n    }\n    const { status, signatures = [], requestId } = queryResponse;\n\n    const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n    for (const sig of signatures) {\n      const { timestamp, identity } = sig;\n      const nodeId = Principal.fromUint8Array(identity).toText();\n      let hash: ArrayBuffer;\n\n      // Hash is constructed differently depending on the status\n      if (status === 'replied') {\n        const { reply } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reply: reply,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else if (status === 'rejected') {\n        const { reject_code, reject_message, error_code } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reject_code: reject_code,\n          reject_message: reject_message,\n          error_code: error_code,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else {\n        throw new Error(`Unknown status: ${status}`);\n      }\n\n      const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n\n      // FIX: check for match without verifying N times\n      const pubKey = subnetStatus?.nodeKeys.get(nodeId);\n      if (!pubKey) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n      const valid = ed25519.verify(\n        sig.signature,\n        new Uint8Array(separatorWithHash),\n        new Uint8Array(rawKey),\n      );\n      if (valid) return queryResponse;\n\n      throw new CertificateVerificationError(\n        `Invalid signature from replica ${nodeId} signed query.`,\n      );\n    }\n    return queryResponse;\n  };\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      },\n    });\n\n    // Apply transform for identity.\n    return id?.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n\n    const transformedRequest = request ?? (await this.createReadStateRequest(fields, identity));\n    const body = cbor.encode(transformedRequest.body);\n\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const response = await this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), {\n        ...this._fetchOptions,\n        ...transformedRequest.request,\n        body,\n      }),\n    );\n\n    if (!response.ok) {\n      throw new Error(\n        `Server returned an error:\\n` +\n          `  Code: ${response.status} (${response.statusText})\\n` +\n          `  Body: ${await response.text()}\\n`,\n      );\n    }\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  public async syncTime(canisterId?: Principal): Promise<void> {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        console.log(\n          'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n        );\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time'],\n      });\n\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this._timeDiffMsecs = Number(replicaTime as any) - Number(callTime);\n      }\n    } catch (error) {\n      console.error('Caught exception while attempting to sync time:', error);\n    }\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this._credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this._credentials),\n        }\n      : {};\n\n    const response = await this._requestAndRetry(() =>\n      this._fetch('' + new URL(`/api/v2/status`, this._host), { headers, ...this._fetchOptions }),\n    );\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    if (!this._rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = ((await this.status()) as any).root_key;\n      this._rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n\n  public invalidateIdentity(): void {\n    this._identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this._identity = Promise.resolve(identity);\n  }\n\n  public async fetchSubnetKeys(canisterId: Principal | string) {\n    const effectiveCanisterId: Principal = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this,\n    });\n\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse as SubnetStatus);\n      return subnetResponse as SubnetStatus;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n\n    return p;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}