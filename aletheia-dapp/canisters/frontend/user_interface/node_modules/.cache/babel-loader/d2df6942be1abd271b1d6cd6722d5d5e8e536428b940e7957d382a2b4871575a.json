{"ast":null,"code":"import * as base64Arraybuffer from 'base64-arraybuffer';\n// This WASM is generated from the miracl BLS Rust code (see\n// https://github.com/dfinity/miracl_core_bls12381/)\nimport { wasmBytesBase64 } from './wasm';\nlet wasm;\nconst wasmBytes = base64Arraybuffer.decode(wasmBytesBase64);\n/**\n * @returns {number}\n */\nexport function bls_init() {\n  let ret = wasm.bls_init();\n  return ret;\n}\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachegetUint8Memory0;\n}\nfunction passArray8ToWasm0(arg, malloc) {\n  const ptr = malloc(arg.length * 1);\n  getUint8Memory0().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\n/**\n * @param {Uint8Array} sig\n * @param {Uint8Array} m\n * @param {Uint8Array} w\n * @returns {number}\n */\nexport function bls_verify(sig, m, w) {\n  const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);\n  const [ptr1, len1] = passArray8ToWasm0(m, wasm.__wbindgen_malloc);\n  const [ptr2, len2] = passArray8ToWasm0(w, wasm.__wbindgen_malloc);\n  const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);\n  return ret;\n}\nasync function load(module, imports) {\n  if (typeof Response === 'function' && module instanceof Response) {\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n    if (instance instanceof WebAssembly.Instance) {\n      return {\n        instance,\n        module\n      };\n    } else {\n      return instance;\n    }\n  }\n}\nasync function init() {\n  const imports = {};\n  const {\n    instance,\n    module\n  } = await load(wasmBytes, imports);\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  return wasm;\n}\n/**\n * If `module_or_path` is {RequestInfo} or {URL}, makes a request and\n * for everything else, calls `WebAssembly.instantiate` directly.\n *\n * @param {InitInput | Promise<InitInput>} module_or_path\n *\n * @returns {Promise<InitOutput>}\n */\nexport default init;","map":{"version":3,"names":["base64Arraybuffer","wasmBytesBase64","wasm","wasmBytes","decode","bls_init","ret","cachegetUint8Memory0","getUint8Memory0","buffer","memory","Uint8Array","passArray8ToWasm0","arg","malloc","ptr","length","set","bls_verify","sig","m","w","ptr0","len0","__wbindgen_malloc","ptr1","len1","ptr2","len2","load","module","imports","Response","bytes","arrayBuffer","WebAssembly","instantiate","instance","Instance","init","exports","__wbindgen_wasm_module"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\vendor\\bls\\bls.ts"],"sourcesContent":["import * as base64Arraybuffer from 'base64-arraybuffer';\n\n// This WASM is generated from the miracl BLS Rust code (see\n// https://github.com/dfinity/miracl_core_bls12381/)\nimport { wasmBytesBase64 } from './wasm';\n\nlet wasm: InitOutput;\n\nconst wasmBytes = base64Arraybuffer.decode(wasmBytesBase64);\n\n/**\n * @returns {number}\n */\nexport function bls_init() {\n  let ret = wasm.bls_init();\n  return ret;\n}\n\nlet cachegetUint8Memory0: any = null;\nfunction getUint8Memory0() {\n  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachegetUint8Memory0;\n}\n\nfunction passArray8ToWasm0(arg: any, malloc: any): [number, number] {\n  const ptr = malloc(arg.length * 1);\n  getUint8Memory0().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\n\n/**\n * @param {Uint8Array} sig\n * @param {Uint8Array} m\n * @param {Uint8Array} w\n * @returns {number}\n */\nexport function bls_verify(sig: Uint8Array, m: Uint8Array, w: Uint8Array): number {\n  const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);\n  const [ptr1, len1] = passArray8ToWasm0(m, wasm.__wbindgen_malloc);\n  const [ptr2, len2] = passArray8ToWasm0(w, wasm.__wbindgen_malloc);\n\n  const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);\n  return ret;\n}\n\nasync function load(module: any, imports: any) {\n  if (typeof Response === 'function' && module instanceof Response) {\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nasync function init(): Promise<InitOutput> {\n  const imports = {};\n  const { instance, module } = await load(wasmBytes, imports);\n\n  wasm = instance.exports as any as InitOutput;\n  (init as any).__wbindgen_wasm_module = module;\n\n  return wasm;\n}\n\nexport type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;\n\nexport interface InitOutput {\n  readonly memory: WebAssembly.Memory;\n  readonly bls_init: () => number;\n  readonly bls_verify: (a: number, b: number, c: number, d: number, e: number, f: number) => number;\n  readonly __wbindgen_malloc: (a: number) => number;\n}\n\n/**\n * If `module_or_path` is {RequestInfo} or {URL}, makes a request and\n * for everything else, calls `WebAssembly.instantiate` directly.\n *\n * @param {InitInput | Promise<InitInput>} module_or_path\n *\n * @returns {Promise<InitOutput>}\n */\nexport default init;\n"],"mappings":"AAAA,OAAO,KAAKA,iBAAiB,MAAM,oBAAoB;AAEvD;AACA;AACA,SAASC,eAAe,QAAQ,QAAQ;AAExC,IAAIC,IAAgB;AAEpB,MAAMC,SAAS,GAAGH,iBAAiB,CAACI,MAAM,CAACH,eAAe,CAAC;AAE3D;;;AAGA,OAAM,SAAUI,QAAQA,CAAA;EACtB,IAAIC,GAAG,GAAGJ,IAAI,CAACG,QAAQ,EAAE;EACzB,OAAOC,GAAG;AACZ;AAEA,IAAIC,oBAAoB,GAAQ,IAAI;AACpC,SAASC,eAAeA,CAAA;EACtB,IAAID,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,CAACE,MAAM,KAAKP,IAAI,CAACQ,MAAM,CAACD,MAAM,EAAE;IACvFF,oBAAoB,GAAG,IAAII,UAAU,CAACT,IAAI,CAACQ,MAAM,CAACD,MAAM,CAAC;;EAE3D,OAAOF,oBAAoB;AAC7B;AAEA,SAASK,iBAAiBA,CAACC,GAAQ,EAAEC,MAAW;EAC9C,MAAMC,GAAG,GAAGD,MAAM,CAACD,GAAG,CAACG,MAAM,GAAG,CAAC,CAAC;EAClCR,eAAe,EAAE,CAACS,GAAG,CAACJ,GAAG,EAAEE,GAAG,GAAG,CAAC,CAAC;EACnC,OAAO,CAACA,GAAG,EAAEF,GAAG,CAACG,MAAM,CAAC;AAC1B;AAEA;;;;;;AAMA,OAAM,SAAUE,UAAUA,CAACC,GAAe,EAAEC,CAAa,EAAEC,CAAa;EACtE,MAAM,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAGX,iBAAiB,CAACO,GAAG,EAAEjB,IAAI,CAACsB,iBAAiB,CAAC;EACnE,MAAM,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAGd,iBAAiB,CAACQ,CAAC,EAAElB,IAAI,CAACsB,iBAAiB,CAAC;EACjE,MAAM,CAACG,IAAI,EAAEC,IAAI,CAAC,GAAGhB,iBAAiB,CAACS,CAAC,EAAEnB,IAAI,CAACsB,iBAAiB,CAAC;EAEjE,MAAMlB,GAAG,GAAGJ,IAAI,CAACgB,UAAU,CAACI,IAAI,EAAEC,IAAI,EAAEE,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC;EAC/D,OAAOtB,GAAG;AACZ;AAEA,eAAeuB,IAAIA,CAACC,MAAW,EAAEC,OAAY;EAC3C,IAAI,OAAOC,QAAQ,KAAK,UAAU,IAAIF,MAAM,YAAYE,QAAQ,EAAE;IAChE,MAAMC,KAAK,GAAG,MAAMH,MAAM,CAACI,WAAW,EAAE;IACxC,OAAO,MAAMC,WAAW,CAACC,WAAW,CAACH,KAAK,EAAEF,OAAO,CAAC;GACrD,MAAM;IACL,MAAMM,QAAQ,GAAG,MAAMF,WAAW,CAACC,WAAW,CAACN,MAAM,EAAEC,OAAO,CAAC;IAE/D,IAAIM,QAAQ,YAAYF,WAAW,CAACG,QAAQ,EAAE;MAC5C,OAAO;QAAED,QAAQ;QAAEP;MAAM,CAAE;KAC5B,MAAM;MACL,OAAOO,QAAQ;;;AAGrB;AAEA,eAAeE,IAAIA,CAAA;EACjB,MAAMR,OAAO,GAAG,EAAE;EAClB,MAAM;IAAEM,QAAQ;IAAEP;EAAM,CAAE,GAAG,MAAMD,IAAI,CAAC1B,SAAS,EAAE4B,OAAO,CAAC;EAE3D7B,IAAI,GAAGmC,QAAQ,CAACG,OAA4B;EAC3CD,IAAY,CAACE,sBAAsB,GAAGX,MAAM;EAE7C,OAAO5B,IAAI;AACb;AAWA;;;;;;;;AAQA,eAAeqC,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}