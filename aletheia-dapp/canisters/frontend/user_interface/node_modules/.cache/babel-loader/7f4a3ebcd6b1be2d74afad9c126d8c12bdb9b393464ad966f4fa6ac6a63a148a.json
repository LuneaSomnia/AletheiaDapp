{"ast":null,"code":"/** @module CanisterStatus */\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../errors';\nimport { Certificate, flatten_forks, check_canister_ranges, lookupResultToBuffer, lookup_path } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as Cbor from '../cbor';\nimport { decodeLeb128, decodeTime } from '../utils/leb';\n/**\n *\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async options => {\n  const {\n    agent,\n    paths\n  } = options;\n  const canisterId = Principal.from(options.canisterId);\n  const uniquePaths = [...new Set(paths)];\n  // Map path options to their correct formats\n  const encodedPaths = uniquePaths.map(path => {\n    return encodePath(path, canisterId);\n  });\n  const status = new Map();\n  const promises = uniquePaths.map((path, index) => {\n    return (async () => {\n      var _a;\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPaths[index]]\n        });\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId\n        });\n        const lookup = (cert, path) => {\n          if (path === 'subnet') {\n            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n            return {\n              path: path,\n              data\n            };\n          } else {\n            return {\n              path: path,\n              data: lookupResultToBuffer(cert.lookup(encodePath(path, canisterId)))\n            };\n          }\n        };\n        // must pass in the rootKey if we have no delegation\n        const {\n          path,\n          data\n        } = lookup(cert, uniquePaths[index]);\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time':\n              {\n                status.set(path, decodeTime(data));\n                break;\n              }\n            case 'controllers':\n              {\n                status.set(path, decodeControllers(data));\n                break;\n              }\n            case 'module_hash':\n              {\n                status.set(path, decodeHex(data));\n                break;\n              }\n            case 'subnet':\n              {\n                status.set(path, data);\n                break;\n              }\n            case 'candid':\n              {\n                status.set(path, new TextDecoder().decode(data));\n                break;\n              }\n            default:\n              {\n                // Check for CustomPath signature\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                  switch (path.decodeStrategy) {\n                    case 'raw':\n                      status.set(path.key, data);\n                      break;\n                    case 'leb128':\n                      {\n                        status.set(path.key, decodeLeb128(data));\n                        break;\n                      }\n                    case 'cbor':\n                      {\n                        status.set(path.key, decodeCbor(data));\n                        break;\n                      }\n                    case 'hex':\n                      {\n                        status.set(path.key, decodeHex(data));\n                        break;\n                      }\n                    case 'utf-8':\n                      {\n                        status.set(path.key, decodeUtf8(data));\n                      }\n                  }\n                }\n              }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {\n          throw new AgentError(error.message);\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n  return status;\n};\nexport const fetchNodeKeys = (certificate, canisterId, root_key) => {\n  if (!canisterId._isPrincipal) {\n    throw new Error('Invalid canisterId');\n  }\n  const cert = Cbor.decode(new Uint8Array(certificate));\n  const tree = cert.tree;\n  let delegation = cert.delegation;\n  let subnetId;\n  if (delegation && delegation.subnet_id) {\n    subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n  }\n  // On local replica, with System type subnet, there is no delegation\n  else if (!delegation && typeof root_key !== 'undefined') {\n    subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new ArrayBuffer(0)\n    };\n  }\n  // otherwise use default NNS subnet id\n  else {\n    subnetId = Principal.selfAuthenticating(Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new ArrayBuffer(0)\n    };\n  }\n  const canisterInRange = check_canister_ranges({\n    canisterId,\n    subnetId,\n    tree\n  });\n  if (!canisterInRange) {\n    throw new Error('Canister not in range');\n  }\n  const nodeTree = lookup_path(['subnet', delegation === null || delegation === void 0 ? void 0 : delegation.subnet_id, 'node'], tree);\n  const nodeForks = flatten_forks(nodeTree);\n  nodeForks.length;\n  const nodeKeys = new Map();\n  nodeForks.forEach(fork => {\n    Object.getPrototypeOf(new Uint8Array(fork[1]));\n    const node_id = Principal.from(new Uint8Array(fork[1])).toText();\n    const derEncodedPublicKey = lookup_path(['public_key'], fork[2]);\n    if (derEncodedPublicKey.byteLength !== 44) {\n      throw new Error('Invalid public key length');\n    } else {\n      nodeKeys.set(node_id, derEncodedPublicKey);\n    }\n  });\n  return {\n    subnetId: Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n    nodeKeys\n  };\n};\nexport const encodePath = (path, canisterId) => {\n  const encoder = new TextEncoder();\n  const encode = arg => {\n    return new DataView(encoder.encode(arg).buffer).buffer;\n  };\n  const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n  switch (path) {\n    case 'time':\n      return [encode('time')];\n    case 'controllers':\n      return [encode('canister'), canisterBuffer, encode('controllers')];\n    case 'module_hash':\n      return [encode('canister'), canisterBuffer, encode('module_hash')];\n    case 'subnet':\n      return [encode('subnet')];\n    case 'candid':\n      return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n    default:\n      {\n        // Check for CustomPath signature\n        if ('key' in path && 'path' in path) {\n          // For simplified metadata queries\n          if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n            const metaPath = path.path;\n            const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n            return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n            // For non-metadata, return the provided custompath\n          } else {\n            return path['path'];\n          }\n        }\n      }\n  }\n  throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);\n};\nconst decodeHex = buf => {\n  return toHex(buf);\n};\nconst decodeCbor = buf => {\n  return Cbor.decode(buf);\n};\nconst decodeUtf8 = buf => {\n  return new TextDecoder().decode(buf);\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = buf => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const controllersRaw = decodeCbor(buf);\n  return controllersRaw.map(buf => {\n    return Principal.fromUint8Array(new Uint8Array(buf));\n  });\n};","map":{"version":3,"names":["Principal","AgentError","Certificate","flatten_forks","check_canister_ranges","lookupResultToBuffer","lookup_path","toHex","Cbor","decodeLeb128","decodeTime","request","options","agent","paths","canisterId","from","uniquePaths","Set","encodedPaths","map","path","encodePath","status","Map","promises","index","response","readState","cert","create","certificate","rootKey","lookup","data","fetchNodeKeys","console","warn","set","key","decodeControllers","decodeHex","TextDecoder","decode","decodeStrategy","decodeCbor","decodeUtf8","error","_a","message","includes","group","groupEnd","Promise","all","root_key","_isPrincipal","Error","Uint8Array","tree","delegation","subnetId","subnet_id","fromUint8Array","selfAuthenticating","toUint8Array","ArrayBuffer","fromText","canisterInRange","nodeTree","nodeForks","length","nodeKeys","forEach","fork","Object","getPrototypeOf","node_id","toText","derEncodedPublicKey","byteLength","encoder","TextEncoder","encode","arg","DataView","buffer","canisterBuffer","metaPath","encoded","buf","controllersRaw"],"sources":["C:\\Users\\pc\\Desktop\\aletheia-dapp\\aletheia-dapp\\canisters\\frontend\\user_interface\\node_modules\\@dfinity\\agent\\src\\canisterStatus\\index.ts"],"sourcesContent":["/** @module CanisterStatus */\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../errors';\nimport { HttpAgent } from '../agent/http';\nimport {\n  Cert,\n  Certificate,\n  CreateCertificateOptions,\n  HashTree,\n  flatten_forks,\n  check_canister_ranges,\n  lookupResultToBuffer,\n  lookup_path,\n} from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as Cbor from '../cbor';\nimport { decodeLeb128, decodeTime } from '../utils/leb';\nimport { DerEncodedPublicKey } from '..';\n\n/**\n * Represents the useful information about a subnet\n * @param {string} subnetId the principal id of the canister's subnet\n * @param {string[]} nodeKeys the keys of the individual nodes in the subnet\n */\nexport type SubnetStatus = {\n  // Principal as a string\n  subnetId: string;\n  nodeKeys: Map<string, DerEncodedPublicKey>;\n  metrics?: {\n    num_canisters: bigint;\n    canister_state_bytes: bigint;\n    consumed_cycles_total: {\n      current: bigint;\n      deleted: bigint;\n    };\n    update_transactions_total: bigint;\n  };\n};\n\n/**\n * Types of an entry on the canisterStatus map.\n * An entry of null indicates that the request failed, due to lack of permissions or the result being missing.\n */\nexport type Status =\n  | string\n  | ArrayBuffer\n  | Date\n  | ArrayBuffer[]\n  | Principal[]\n  | SubnetStatus\n  | bigint\n  | null;\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using {@link TextEncoder}\n */\nexport interface CustomPath {\n  key: string;\n  path: ArrayBuffer[] | string;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Interface to request metadata from the icp:public or icp:private sections.\n * Similar to {@link CustomPath}, but accepts a simple string argument.\n * Private metadata will require the ${@link Identity} used by the ${@link HttpAgent} will need to be requested using an identity that controlls the canister.\n */\nexport interface MetaData {\n  kind: 'metadata';\n  key: string;\n  path: string | ArrayBuffer;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Pre-configured fields for canister status paths\n */\nexport type Path =\n  | 'time'\n  | 'controllers'\n  | 'subnet'\n  | 'module_hash'\n  | 'candid'\n  | MetaData\n  | CustomPath;\n\nexport type StatusMap = Map<Path | string, Status>;\n\nexport type CanisterStatusOptions = {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n};\n\n/**\n *\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async (options: {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n}): Promise<StatusMap> => {\n  const { agent, paths } = options;\n  const canisterId = Principal.from(options.canisterId);\n\n  const uniquePaths = [...new Set(paths)];\n\n  // Map path options to their correct formats\n  const encodedPaths = uniquePaths.map(path => {\n    return encodePath(path, canisterId);\n  });\n  const status = new Map<string | Path, Status>();\n\n  const promises = uniquePaths.map((path, index) => {\n    return (async () => {\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPaths[index]],\n        });\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId,\n        });\n\n        const lookup = (cert: Certificate, path: Path) => {\n          if (path === 'subnet') {\n            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n            return {\n              path: path,\n              data,\n            };\n          } else {\n            return {\n              path: path,\n              data: lookupResultToBuffer(cert.lookup(encodePath(path, canisterId))),\n            };\n          }\n        };\n\n        // must pass in the rootKey if we have no delegation\n        const { path, data } = lookup(cert, uniquePaths[index]);\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time': {\n              status.set(path, decodeTime(data));\n              break;\n            }\n            case 'controllers': {\n              status.set(path, decodeControllers(data));\n              break;\n            }\n            case 'module_hash': {\n              status.set(path, decodeHex(data));\n              break;\n            }\n            case 'subnet': {\n              status.set(path, data);\n              break;\n            }\n            case 'candid': {\n              status.set(path, new TextDecoder().decode(data));\n              break;\n            }\n            default: {\n              // Check for CustomPath signature\n              if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                switch (path.decodeStrategy) {\n                  case 'raw':\n                    status.set(path.key, data);\n                    break;\n                  case 'leb128': {\n                    status.set(path.key, decodeLeb128(data));\n                    break;\n                  }\n                  case 'cbor': {\n                    status.set(path.key, decodeCbor(data));\n                    break;\n                  }\n                  case 'hex': {\n                    status.set(path.key, decodeHex(data));\n                    break;\n                  }\n                  case 'utf-8': {\n                    status.set(path.key, decodeUtf8(data));\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if ((error as AgentError)?.message?.includes('Invalid certificate')) {\n          throw new AgentError((error as AgentError).message);\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n\n  return status;\n};\n\nexport const fetchNodeKeys = (\n  certificate: ArrayBuffer,\n  canisterId: Principal,\n  root_key?: ArrayBuffer | Uint8Array,\n): SubnetStatus => {\n  if (!canisterId._isPrincipal) {\n    throw new Error('Invalid canisterId');\n  }\n  const cert = Cbor.decode(new Uint8Array(certificate)) as Cert;\n  const tree = cert.tree;\n  let delegation = cert.delegation;\n  let subnetId: Principal;\n  if (delegation && delegation.subnet_id) {\n    subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n  }\n\n  // On local replica, with System type subnet, there is no delegation\n  else if (!delegation && typeof root_key !== 'undefined') {\n    subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new ArrayBuffer(0),\n    };\n  }\n  // otherwise use default NNS subnet id\n  else {\n    subnetId = Principal.selfAuthenticating(\n      Principal.fromText(\n        'tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe',\n      ).toUint8Array(),\n    );\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new ArrayBuffer(0),\n    };\n  }\n\n  const canisterInRange = check_canister_ranges({ canisterId, subnetId, tree });\n  if (!canisterInRange) {\n    throw new Error('Canister not in range');\n  }\n\n  const nodeTree = lookup_path(['subnet', delegation?.subnet_id as ArrayBuffer, 'node'], tree);\n  const nodeForks = flatten_forks(nodeTree as HashTree) as HashTree[];\n  nodeForks.length;\n  const nodeKeys = new Map<string, DerEncodedPublicKey>();\n  nodeForks.forEach(fork => {\n    Object.getPrototypeOf(new Uint8Array(fork[1] as ArrayBuffer));\n    const node_id = Principal.from(new Uint8Array(fork[1] as ArrayBuffer)).toText();\n    const derEncodedPublicKey = lookup_path(['public_key'], fork[2] as HashTree) as ArrayBuffer;\n    if (derEncodedPublicKey.byteLength !== 44) {\n      throw new Error('Invalid public key length');\n    } else {\n      nodeKeys.set(node_id, derEncodedPublicKey as DerEncodedPublicKey);\n    }\n  });\n\n  return {\n    subnetId: Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n    nodeKeys,\n  };\n};\n\nexport const encodePath = (path: Path, canisterId: Principal): ArrayBuffer[] => {\n  const encoder = new TextEncoder();\n\n  const encode = (arg: string): ArrayBuffer => {\n    return new DataView(encoder.encode(arg).buffer).buffer;\n  };\n  const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n  switch (path) {\n    case 'time':\n      return [encode('time')];\n    case 'controllers':\n      return [encode('canister'), canisterBuffer, encode('controllers')];\n    case 'module_hash':\n      return [encode('canister'), canisterBuffer, encode('module_hash')];\n    case 'subnet':\n      return [encode('subnet')];\n    case 'candid':\n      return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n    default: {\n      // Check for CustomPath signature\n      if ('key' in path && 'path' in path) {\n        // For simplified metadata queries\n        if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n          const metaPath = path.path;\n          const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n\n          return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n\n          // For non-metadata, return the provided custompath\n        } else {\n          return path['path'];\n        }\n      }\n    }\n  }\n  throw new Error(\n    `An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`,\n  );\n};\n\nconst decodeHex = (buf: ArrayBuffer): string => {\n  return toHex(buf);\n};\n\nconst decodeCbor = (buf: ArrayBuffer): ArrayBuffer[] => {\n  return Cbor.decode(buf);\n};\n\nconst decodeUtf8 = (buf: ArrayBuffer): string => {\n  return new TextDecoder().decode(buf);\n};\n\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf: ArrayBuffer): Principal[] => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const controllersRaw = decodeCbor(buf);\n  return controllersRaw.map((buf: ArrayBuffer) => {\n    return Principal.fromUint8Array(new Uint8Array(buf));\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}